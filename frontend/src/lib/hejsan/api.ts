/* tslint:disable */
/* eslint-disable */
/**
 * 
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 0.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * 
 * @export
 * @interface AbbreviatedUser
 */
export interface AbbreviatedUser {
    /**
     * 
     * @type {number}
     * @memberof AbbreviatedUser
     */
    'id': number;
    /**
     * The full name of the user if it exists, otherwise the username
     * @type {string}
     * @memberof AbbreviatedUser
     */
    'label': string | null;
}
/**
 * 
 * @export
 * @interface BusinessArea
 */
export interface BusinessArea {
    /**
     * 
     * @type {number}
     * @memberof BusinessArea
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof BusinessArea
     */
    'slug': string;
    /**
     * 
     * @type {string}
     * @memberof BusinessArea
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof BusinessArea
     */
    'description'?: string;
    /**
     * 
     * @type {Array<number>}
     * @memberof BusinessArea
     */
    'users'?: Array<number>;
}
/**
 * 
 * @export
 * @interface Campaign
 */
export interface Campaign {
    /**
     * 
     * @type {number}
     * @memberof Campaign
     */
    'id': number;
    /**
     * 
     * @type {AbbreviatedUser}
     * @memberof Campaign
     */
    'created_by': AbbreviatedUser;
    /**
     * 
     * @type {string}
     * @memberof Campaign
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof Campaign
     */
    'description': string;
    /**
     * 
     * @type {string}
     * @memberof Campaign
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof Campaign
     */
    'updated_at': string;
    /**
     * 
     * @type {Array<number>}
     * @memberof Campaign
     */
    'business_areas'?: Array<number>;
}
/**
 * 
 * @export
 * @interface CampaignRound
 */
export interface CampaignRound {
    /**
     * 
     * @type {number}
     * @memberof CampaignRound
     */
    'id': number;
    /**
     * 
     * @type {AbbreviatedUser}
     * @memberof CampaignRound
     */
    'created_by': AbbreviatedUser;
    /**
     * 
     * @type {string}
     * @memberof CampaignRound
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof CampaignRound
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof CampaignRound
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof CampaignRound
     */
    'updated_at': string;
    /**
     * 
     * @type {number}
     * @memberof CampaignRound
     */
    'campaign': number;
}
/**
 * 
 * @export
 * @interface Idea
 */
export interface Idea {
    /**
     * 
     * @type {number}
     * @memberof Idea
     */
    'id': number;
    /**
     * 
     * @type {AbbreviatedUser}
     * @memberof Idea
     */
    'created_by': AbbreviatedUser;
    /**
     * 
     * @type {string}
     * @memberof Idea
     */
    'title': string;
    /**
     * 
     * @type {string}
     * @memberof Idea
     */
    'description': string;
    /**
     * 
     * @type {string}
     * @memberof Idea
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof Idea
     */
    'updated_at': string;
    /**
     * 
     * @type {VisibilityEnum}
     * @memberof Idea
     */
    'visibility'?: VisibilityEnum;
    /**
     * 
     * @type {number}
     * @memberof Idea
     */
    'campaign': number;
}


/**
 * 
 * @export
 * @interface IdeaDetail
 */
export interface IdeaDetail {
    /**
     * 
     * @type {number}
     * @memberof IdeaDetail
     */
    'id': number;
    /**
     * 
     * @type {AbbreviatedUser}
     * @memberof IdeaDetail
     */
    'created_by': AbbreviatedUser;
    /**
     * 
     * @type {Array<RoundVotes>}
     * @memberof IdeaDetail
     */
    'round_votes': Array<RoundVotes>;
    /**
     * 
     * @type {string}
     * @memberof IdeaDetail
     */
    'title': string;
    /**
     * 
     * @type {string}
     * @memberof IdeaDetail
     */
    'description': string;
    /**
     * 
     * @type {string}
     * @memberof IdeaDetail
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof IdeaDetail
     */
    'updated_at': string;
    /**
     * 
     * @type {VisibilityEnum}
     * @memberof IdeaDetail
     */
    'visibility'?: VisibilityEnum;
    /**
     * 
     * @type {number}
     * @memberof IdeaDetail
     */
    'campaign': number;
}


/**
 * 
 * @export
 * @interface IdeaInformation
 */
export interface IdeaInformation {
    /**
     * 
     * @type {number}
     * @memberof IdeaInformation
     */
    'id': number;
    /**
     * 
     * @type {AbbreviatedUser}
     * @memberof IdeaInformation
     */
    'created_by': AbbreviatedUser;
    /**
     * 
     * @type {string}
     * @memberof IdeaInformation
     */
    'deleted_at'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof IdeaInformation
     */
    'restored_at'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof IdeaInformation
     */
    'transaction_id'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof IdeaInformation
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof IdeaInformation
     */
    'updated_at': string;
    /**
     * 
     * @type {string}
     * @memberof IdeaInformation
     */
    'title'?: string;
    /**
     * 
     * @type {string}
     * @memberof IdeaInformation
     */
    'text'?: string;
    /**
     * 
     * @type {number}
     * @memberof IdeaInformation
     */
    'idea'?: number;
    /**
     * 
     * @type {number}
     * @memberof IdeaInformation
     */
    'folder'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof IdeaInformation
     */
    'round'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof IdeaInformation
     */
    'file'?: number | null;
}
/**
 * 
 * @export
 * @interface Login
 */
export interface Login {
    /**
     * 
     * @type {string}
     * @memberof Login
     */
    'username': string;
    /**
     * 
     * @type {string}
     * @memberof Login
     */
    'password': string;
}
/**
 * 
 * @export
 * @interface PatchedBusinessArea
 */
export interface PatchedBusinessArea {
    /**
     * 
     * @type {number}
     * @memberof PatchedBusinessArea
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof PatchedBusinessArea
     */
    'slug'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedBusinessArea
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedBusinessArea
     */
    'description'?: string;
    /**
     * 
     * @type {Array<number>}
     * @memberof PatchedBusinessArea
     */
    'users'?: Array<number>;
}
/**
 * 
 * @export
 * @interface PatchedCampaign
 */
export interface PatchedCampaign {
    /**
     * 
     * @type {number}
     * @memberof PatchedCampaign
     */
    'id'?: number;
    /**
     * 
     * @type {AbbreviatedUser}
     * @memberof PatchedCampaign
     */
    'created_by'?: AbbreviatedUser;
    /**
     * 
     * @type {string}
     * @memberof PatchedCampaign
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedCampaign
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedCampaign
     */
    'created_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedCampaign
     */
    'updated_at'?: string;
    /**
     * 
     * @type {Array<number>}
     * @memberof PatchedCampaign
     */
    'business_areas'?: Array<number>;
}
/**
 * 
 * @export
 * @interface PatchedCampaignRound
 */
export interface PatchedCampaignRound {
    /**
     * 
     * @type {number}
     * @memberof PatchedCampaignRound
     */
    'id'?: number;
    /**
     * 
     * @type {AbbreviatedUser}
     * @memberof PatchedCampaignRound
     */
    'created_by'?: AbbreviatedUser;
    /**
     * 
     * @type {string}
     * @memberof PatchedCampaignRound
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedCampaignRound
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedCampaignRound
     */
    'created_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedCampaignRound
     */
    'updated_at'?: string;
    /**
     * 
     * @type {number}
     * @memberof PatchedCampaignRound
     */
    'campaign'?: number;
}
/**
 * 
 * @export
 * @interface PatchedIdea
 */
export interface PatchedIdea {
    /**
     * 
     * @type {number}
     * @memberof PatchedIdea
     */
    'id'?: number;
    /**
     * 
     * @type {AbbreviatedUser}
     * @memberof PatchedIdea
     */
    'created_by'?: AbbreviatedUser;
    /**
     * 
     * @type {string}
     * @memberof PatchedIdea
     */
    'title'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedIdea
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedIdea
     */
    'created_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedIdea
     */
    'updated_at'?: string;
    /**
     * 
     * @type {VisibilityEnum}
     * @memberof PatchedIdea
     */
    'visibility'?: VisibilityEnum;
    /**
     * 
     * @type {number}
     * @memberof PatchedIdea
     */
    'campaign'?: number;
}


/**
 * 
 * @export
 * @interface PatchedIdeaInformation
 */
export interface PatchedIdeaInformation {
    /**
     * 
     * @type {number}
     * @memberof PatchedIdeaInformation
     */
    'id'?: number;
    /**
     * 
     * @type {AbbreviatedUser}
     * @memberof PatchedIdeaInformation
     */
    'created_by'?: AbbreviatedUser;
    /**
     * 
     * @type {string}
     * @memberof PatchedIdeaInformation
     */
    'deleted_at'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PatchedIdeaInformation
     */
    'restored_at'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PatchedIdeaInformation
     */
    'transaction_id'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PatchedIdeaInformation
     */
    'created_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedIdeaInformation
     */
    'updated_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedIdeaInformation
     */
    'title'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedIdeaInformation
     */
    'text'?: string;
    /**
     * 
     * @type {number}
     * @memberof PatchedIdeaInformation
     */
    'idea'?: number;
    /**
     * 
     * @type {number}
     * @memberof PatchedIdeaInformation
     */
    'folder'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof PatchedIdeaInformation
     */
    'round'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof PatchedIdeaInformation
     */
    'file'?: number | null;
}
/**
 * 
 * @export
 * @interface PatchedRelatedFile
 */
export interface PatchedRelatedFile {
    /**
     * 
     * @type {string}
     * @memberof PatchedRelatedFile
     */
    'related_model'?: string;
    /**
     * 
     * @type {number}
     * @memberof PatchedRelatedFile
     */
    'related_pk'?: number;
    /**
     * 
     * @type {string}
     * @memberof PatchedRelatedFile
     */
    'file'?: string;
}
/**
 * 
 * @export
 * @interface RelatedFile
 */
export interface RelatedFile {
    /**
     * 
     * @type {string}
     * @memberof RelatedFile
     */
    'related_model': string;
    /**
     * 
     * @type {number}
     * @memberof RelatedFile
     */
    'related_pk': number;
    /**
     * 
     * @type {string}
     * @memberof RelatedFile
     */
    'file': string;
}
/**
 * 
 * @export
 * @interface RoundVotes
 */
export interface RoundVotes {
    /**
     * 
     * @type {number}
     * @memberof RoundVotes
     */
    'round_pk': number;
    /**
     * 
     * @type {number}
     * @memberof RoundVotes
     */
    'count': number;
}
/**
 * * `CONTRIBUTOR` - Contributor * `MODERATOR` - Moderator * `ADMIN` - Admin
 * @export
 * @enum {string}
 */

export const TypeEnum = {
    Contributor: 'CONTRIBUTOR',
    Moderator: 'MODERATOR',
    Admin: 'ADMIN'
} as const;

export type TypeEnum = typeof TypeEnum[keyof typeof TypeEnum];


/**
 * 
 * @export
 * @interface UserProfile
 */
export interface UserProfile {
    /**
     * 
     * @type {number}
     * @memberof UserProfile
     */
    'id': number;
    /**
     * 
     * @type {TypeEnum}
     * @memberof UserProfile
     */
    'type'?: TypeEnum;
    /**
     * 
     * @type {number}
     * @memberof UserProfile
     */
    'user': number;
}


/**
 * 
 * @export
 * @interface UserWithPermissions
 */
export interface UserWithPermissions {
    /**
     * 
     * @type {number}
     * @memberof UserWithPermissions
     */
    'id': number;
    /**
     * The full name of the user if it exists, otherwise the username
     * @type {string}
     * @memberof UserWithPermissions
     */
    'label': string | null;
    /**
     * Required. 150 characters or fewer. Letters, digits and @/./+/-/_ only.
     * @type {string}
     * @memberof UserWithPermissions
     */
    'username': string;
    /**
     * 
     * @type {string}
     * @memberof UserWithPermissions
     */
    'email'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserWithPermissions
     */
    'first_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserWithPermissions
     */
    'last_name'?: string;
    /**
     * 
     * @type {UserProfile}
     * @memberof UserWithPermissions
     */
    'profile': UserProfile;
    /**
     * 
     * @type {string}
     * @memberof UserWithPermissions
     */
    'permissions': string;
    /**
     * 
     * @type {string}
     * @memberof UserWithPermissions
     */
    'group_permissions': string;
    /**
     * 
     * @type {boolean}
     * @memberof UserWithPermissions
     */
    'is_staff': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof UserWithPermissions
     */
    'is_superuser': boolean;
}
/**
 * * `PUBLIC` - Public * `BUSINESS_AREA` - Business Area * `PRIVATE` - Private
 * @export
 * @enum {string}
 */

export const VisibilityEnum = {
    Public: 'PUBLIC',
    BusinessArea: 'BUSINESS_AREA',
    Private: 'PRIVATE'
} as const;

export type VisibilityEnum = typeof VisibilityEnum[keyof typeof VisibilityEnum];


/**
 * 
 * @export
 * @interface Vote
 */
export interface Vote {
    /**
     * 
     * @type {number}
     * @memberof Vote
     */
    'id': number;
    /**
     * 
     * @type {AbbreviatedUser}
     * @memberof Vote
     */
    'created_by': AbbreviatedUser;
    /**
     * 
     * @type {string}
     * @memberof Vote
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof Vote
     */
    'updated_at': string;
    /**
     * 
     * @type {number}
     * @memberof Vote
     */
    'idea': number;
    /**
     * 
     * @type {number}
     * @memberof Vote
     */
    'round': number;
}

/**
 * AuthApi - axios parameter creator
 * @export
 */
export const AuthApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {Login} login 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authLoginCreate: async (login: Login, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'login' is not null or undefined
            assertParamExists('authLoginCreate', 'login', login)
            const localVarPath = `/api/auth/login/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(login, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authLogoutCreate: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/auth/logout/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AuthApi - functional programming interface
 * @export
 */
export const AuthApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AuthApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {Login} login 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authLoginCreate(login: Login, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Login>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authLoginCreate(login, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.authLoginCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authLogoutCreate(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authLogoutCreate(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.authLogoutCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AuthApi - factory interface
 * @export
 */
export const AuthApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AuthApiFp(configuration)
    return {
        /**
         * 
         * @param {Login} login 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authLoginCreate(login: Login, options?: RawAxiosRequestConfig): AxiosPromise<Login> {
            return localVarFp.authLoginCreate(login, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authLogoutCreate(options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.authLogoutCreate(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AuthApi - object-oriented interface
 * @export
 * @class AuthApi
 * @extends {BaseAPI}
 */
export class AuthApi extends BaseAPI {
    /**
     * 
     * @param {Login} login 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authLoginCreate(login: Login, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).authLoginCreate(login, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authLogoutCreate(options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).authLogoutCreate(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * BusinessApi - axios parameter creator
 * @export
 */
export const BusinessApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {BusinessArea} businessArea 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        businessBusinessAreaCreate: async (businessArea: BusinessArea, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'businessArea' is not null or undefined
            assertParamExists('businessBusinessAreaCreate', 'businessArea', businessArea)
            const localVarPath = `/api/business/business_area//`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(businessArea, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this business area.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        businessBusinessAreaDestroy: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('businessBusinessAreaDestroy', 'id', id)
            const localVarPath = `/api/business/business_area//{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        businessBusinessAreaList: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/business/business_area//`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this business area.
         * @param {PatchedBusinessArea} [patchedBusinessArea] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        businessBusinessAreaPartialUpdate: async (id: number, patchedBusinessArea?: PatchedBusinessArea, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('businessBusinessAreaPartialUpdate', 'id', id)
            const localVarPath = `/api/business/business_area//{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedBusinessArea, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this business area.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        businessBusinessAreaRetrieve: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('businessBusinessAreaRetrieve', 'id', id)
            const localVarPath = `/api/business/business_area//{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this business area.
         * @param {BusinessArea} businessArea 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        businessBusinessAreaUpdate: async (id: number, businessArea: BusinessArea, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('businessBusinessAreaUpdate', 'id', id)
            // verify required parameter 'businessArea' is not null or undefined
            assertParamExists('businessBusinessAreaUpdate', 'businessArea', businessArea)
            const localVarPath = `/api/business/business_area//{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(businessArea, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BusinessApi - functional programming interface
 * @export
 */
export const BusinessApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = BusinessApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {BusinessArea} businessArea 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async businessBusinessAreaCreate(businessArea: BusinessArea, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BusinessArea>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.businessBusinessAreaCreate(businessArea, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BusinessApi.businessBusinessAreaCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this business area.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async businessBusinessAreaDestroy(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.businessBusinessAreaDestroy(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BusinessApi.businessBusinessAreaDestroy']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async businessBusinessAreaList(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<BusinessArea>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.businessBusinessAreaList(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BusinessApi.businessBusinessAreaList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this business area.
         * @param {PatchedBusinessArea} [patchedBusinessArea] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async businessBusinessAreaPartialUpdate(id: number, patchedBusinessArea?: PatchedBusinessArea, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BusinessArea>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.businessBusinessAreaPartialUpdate(id, patchedBusinessArea, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BusinessApi.businessBusinessAreaPartialUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this business area.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async businessBusinessAreaRetrieve(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BusinessArea>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.businessBusinessAreaRetrieve(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BusinessApi.businessBusinessAreaRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this business area.
         * @param {BusinessArea} businessArea 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async businessBusinessAreaUpdate(id: number, businessArea: BusinessArea, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BusinessArea>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.businessBusinessAreaUpdate(id, businessArea, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BusinessApi.businessBusinessAreaUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * BusinessApi - factory interface
 * @export
 */
export const BusinessApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = BusinessApiFp(configuration)
    return {
        /**
         * 
         * @param {BusinessArea} businessArea 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        businessBusinessAreaCreate(businessArea: BusinessArea, options?: RawAxiosRequestConfig): AxiosPromise<BusinessArea> {
            return localVarFp.businessBusinessAreaCreate(businessArea, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this business area.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        businessBusinessAreaDestroy(id: number, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.businessBusinessAreaDestroy(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        businessBusinessAreaList(options?: RawAxiosRequestConfig): AxiosPromise<Array<BusinessArea>> {
            return localVarFp.businessBusinessAreaList(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this business area.
         * @param {PatchedBusinessArea} [patchedBusinessArea] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        businessBusinessAreaPartialUpdate(id: number, patchedBusinessArea?: PatchedBusinessArea, options?: RawAxiosRequestConfig): AxiosPromise<BusinessArea> {
            return localVarFp.businessBusinessAreaPartialUpdate(id, patchedBusinessArea, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this business area.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        businessBusinessAreaRetrieve(id: number, options?: RawAxiosRequestConfig): AxiosPromise<BusinessArea> {
            return localVarFp.businessBusinessAreaRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this business area.
         * @param {BusinessArea} businessArea 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        businessBusinessAreaUpdate(id: number, businessArea: BusinessArea, options?: RawAxiosRequestConfig): AxiosPromise<BusinessArea> {
            return localVarFp.businessBusinessAreaUpdate(id, businessArea, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * BusinessApi - object-oriented interface
 * @export
 * @class BusinessApi
 * @extends {BaseAPI}
 */
export class BusinessApi extends BaseAPI {
    /**
     * 
     * @param {BusinessArea} businessArea 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BusinessApi
     */
    public businessBusinessAreaCreate(businessArea: BusinessArea, options?: RawAxiosRequestConfig) {
        return BusinessApiFp(this.configuration).businessBusinessAreaCreate(businessArea, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this business area.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BusinessApi
     */
    public businessBusinessAreaDestroy(id: number, options?: RawAxiosRequestConfig) {
        return BusinessApiFp(this.configuration).businessBusinessAreaDestroy(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BusinessApi
     */
    public businessBusinessAreaList(options?: RawAxiosRequestConfig) {
        return BusinessApiFp(this.configuration).businessBusinessAreaList(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this business area.
     * @param {PatchedBusinessArea} [patchedBusinessArea] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BusinessApi
     */
    public businessBusinessAreaPartialUpdate(id: number, patchedBusinessArea?: PatchedBusinessArea, options?: RawAxiosRequestConfig) {
        return BusinessApiFp(this.configuration).businessBusinessAreaPartialUpdate(id, patchedBusinessArea, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this business area.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BusinessApi
     */
    public businessBusinessAreaRetrieve(id: number, options?: RawAxiosRequestConfig) {
        return BusinessApiFp(this.configuration).businessBusinessAreaRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this business area.
     * @param {BusinessArea} businessArea 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BusinessApi
     */
    public businessBusinessAreaUpdate(id: number, businessArea: BusinessArea, options?: RawAxiosRequestConfig) {
        return BusinessApiFp(this.configuration).businessBusinessAreaUpdate(id, businessArea, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * CampaignApi - axios parameter creator
 * @export
 */
export const CampaignApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {Campaign} campaign 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        campaignCreate: async (campaign: Campaign, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'campaign' is not null or undefined
            assertParamExists('campaignCreate', 'campaign', campaign)
            const localVarPath = `/api/campaign/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(campaign, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this campaign.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        campaignDestroy: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('campaignDestroy', 'id', id)
            const localVarPath = `/api/campaign/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        campaignList: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/campaign/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this campaign.
         * @param {PatchedCampaign} [patchedCampaign] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        campaignPartialUpdate: async (id: number, patchedCampaign?: PatchedCampaign, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('campaignPartialUpdate', 'id', id)
            const localVarPath = `/api/campaign/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedCampaign, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this campaign.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        campaignRetrieve: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('campaignRetrieve', 'id', id)
            const localVarPath = `/api/campaign/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} campaignId 
         * @param {CampaignRound} campaignRound 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        campaignRoundCreate: async (campaignId: string, campaignRound: CampaignRound, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'campaignId' is not null or undefined
            assertParamExists('campaignRoundCreate', 'campaignId', campaignId)
            // verify required parameter 'campaignRound' is not null or undefined
            assertParamExists('campaignRoundCreate', 'campaignRound', campaignRound)
            const localVarPath = `/api/campaign/{campaign_id}/round/`
                .replace(`{${"campaign_id"}}`, encodeURIComponent(String(campaignId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(campaignRound, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} campaignId 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        campaignRoundDestroy: async (campaignId: string, id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'campaignId' is not null or undefined
            assertParamExists('campaignRoundDestroy', 'campaignId', campaignId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('campaignRoundDestroy', 'id', id)
            const localVarPath = `/api/campaign/{campaign_id}/round/{id}/`
                .replace(`{${"campaign_id"}}`, encodeURIComponent(String(campaignId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} campaignId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        campaignRoundList: async (campaignId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'campaignId' is not null or undefined
            assertParamExists('campaignRoundList', 'campaignId', campaignId)
            const localVarPath = `/api/campaign/{campaign_id}/round/`
                .replace(`{${"campaign_id"}}`, encodeURIComponent(String(campaignId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} campaignId 
         * @param {string} id 
         * @param {PatchedCampaignRound} [patchedCampaignRound] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        campaignRoundPartialUpdate: async (campaignId: string, id: string, patchedCampaignRound?: PatchedCampaignRound, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'campaignId' is not null or undefined
            assertParamExists('campaignRoundPartialUpdate', 'campaignId', campaignId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('campaignRoundPartialUpdate', 'id', id)
            const localVarPath = `/api/campaign/{campaign_id}/round/{id}/`
                .replace(`{${"campaign_id"}}`, encodeURIComponent(String(campaignId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedCampaignRound, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} campaignId 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        campaignRoundRetrieve: async (campaignId: string, id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'campaignId' is not null or undefined
            assertParamExists('campaignRoundRetrieve', 'campaignId', campaignId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('campaignRoundRetrieve', 'id', id)
            const localVarPath = `/api/campaign/{campaign_id}/round/{id}/`
                .replace(`{${"campaign_id"}}`, encodeURIComponent(String(campaignId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} campaignId 
         * @param {string} id 
         * @param {CampaignRound} campaignRound 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        campaignRoundUpdate: async (campaignId: string, id: string, campaignRound: CampaignRound, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'campaignId' is not null or undefined
            assertParamExists('campaignRoundUpdate', 'campaignId', campaignId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('campaignRoundUpdate', 'id', id)
            // verify required parameter 'campaignRound' is not null or undefined
            assertParamExists('campaignRoundUpdate', 'campaignRound', campaignRound)
            const localVarPath = `/api/campaign/{campaign_id}/round/{id}/`
                .replace(`{${"campaign_id"}}`, encodeURIComponent(String(campaignId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(campaignRound, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this campaign.
         * @param {Campaign} campaign 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        campaignUpdate: async (id: number, campaign: Campaign, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('campaignUpdate', 'id', id)
            // verify required parameter 'campaign' is not null or undefined
            assertParamExists('campaignUpdate', 'campaign', campaign)
            const localVarPath = `/api/campaign/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(campaign, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CampaignApi - functional programming interface
 * @export
 */
export const CampaignApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CampaignApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {Campaign} campaign 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async campaignCreate(campaign: Campaign, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Campaign>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.campaignCreate(campaign, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CampaignApi.campaignCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this campaign.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async campaignDestroy(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.campaignDestroy(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CampaignApi.campaignDestroy']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async campaignList(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Campaign>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.campaignList(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CampaignApi.campaignList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this campaign.
         * @param {PatchedCampaign} [patchedCampaign] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async campaignPartialUpdate(id: number, patchedCampaign?: PatchedCampaign, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Campaign>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.campaignPartialUpdate(id, patchedCampaign, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CampaignApi.campaignPartialUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this campaign.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async campaignRetrieve(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Campaign>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.campaignRetrieve(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CampaignApi.campaignRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} campaignId 
         * @param {CampaignRound} campaignRound 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async campaignRoundCreate(campaignId: string, campaignRound: CampaignRound, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CampaignRound>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.campaignRoundCreate(campaignId, campaignRound, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CampaignApi.campaignRoundCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} campaignId 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async campaignRoundDestroy(campaignId: string, id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.campaignRoundDestroy(campaignId, id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CampaignApi.campaignRoundDestroy']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} campaignId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async campaignRoundList(campaignId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CampaignRound>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.campaignRoundList(campaignId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CampaignApi.campaignRoundList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} campaignId 
         * @param {string} id 
         * @param {PatchedCampaignRound} [patchedCampaignRound] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async campaignRoundPartialUpdate(campaignId: string, id: string, patchedCampaignRound?: PatchedCampaignRound, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CampaignRound>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.campaignRoundPartialUpdate(campaignId, id, patchedCampaignRound, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CampaignApi.campaignRoundPartialUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} campaignId 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async campaignRoundRetrieve(campaignId: string, id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CampaignRound>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.campaignRoundRetrieve(campaignId, id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CampaignApi.campaignRoundRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} campaignId 
         * @param {string} id 
         * @param {CampaignRound} campaignRound 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async campaignRoundUpdate(campaignId: string, id: string, campaignRound: CampaignRound, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CampaignRound>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.campaignRoundUpdate(campaignId, id, campaignRound, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CampaignApi.campaignRoundUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this campaign.
         * @param {Campaign} campaign 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async campaignUpdate(id: number, campaign: Campaign, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Campaign>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.campaignUpdate(id, campaign, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CampaignApi.campaignUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * CampaignApi - factory interface
 * @export
 */
export const CampaignApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CampaignApiFp(configuration)
    return {
        /**
         * 
         * @param {Campaign} campaign 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        campaignCreate(campaign: Campaign, options?: RawAxiosRequestConfig): AxiosPromise<Campaign> {
            return localVarFp.campaignCreate(campaign, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this campaign.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        campaignDestroy(id: number, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.campaignDestroy(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        campaignList(options?: RawAxiosRequestConfig): AxiosPromise<Array<Campaign>> {
            return localVarFp.campaignList(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this campaign.
         * @param {PatchedCampaign} [patchedCampaign] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        campaignPartialUpdate(id: number, patchedCampaign?: PatchedCampaign, options?: RawAxiosRequestConfig): AxiosPromise<Campaign> {
            return localVarFp.campaignPartialUpdate(id, patchedCampaign, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this campaign.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        campaignRetrieve(id: number, options?: RawAxiosRequestConfig): AxiosPromise<Campaign> {
            return localVarFp.campaignRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} campaignId 
         * @param {CampaignRound} campaignRound 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        campaignRoundCreate(campaignId: string, campaignRound: CampaignRound, options?: RawAxiosRequestConfig): AxiosPromise<CampaignRound> {
            return localVarFp.campaignRoundCreate(campaignId, campaignRound, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} campaignId 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        campaignRoundDestroy(campaignId: string, id: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.campaignRoundDestroy(campaignId, id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} campaignId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        campaignRoundList(campaignId: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<CampaignRound>> {
            return localVarFp.campaignRoundList(campaignId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} campaignId 
         * @param {string} id 
         * @param {PatchedCampaignRound} [patchedCampaignRound] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        campaignRoundPartialUpdate(campaignId: string, id: string, patchedCampaignRound?: PatchedCampaignRound, options?: RawAxiosRequestConfig): AxiosPromise<CampaignRound> {
            return localVarFp.campaignRoundPartialUpdate(campaignId, id, patchedCampaignRound, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} campaignId 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        campaignRoundRetrieve(campaignId: string, id: string, options?: RawAxiosRequestConfig): AxiosPromise<CampaignRound> {
            return localVarFp.campaignRoundRetrieve(campaignId, id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} campaignId 
         * @param {string} id 
         * @param {CampaignRound} campaignRound 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        campaignRoundUpdate(campaignId: string, id: string, campaignRound: CampaignRound, options?: RawAxiosRequestConfig): AxiosPromise<CampaignRound> {
            return localVarFp.campaignRoundUpdate(campaignId, id, campaignRound, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this campaign.
         * @param {Campaign} campaign 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        campaignUpdate(id: number, campaign: Campaign, options?: RawAxiosRequestConfig): AxiosPromise<Campaign> {
            return localVarFp.campaignUpdate(id, campaign, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CampaignApi - object-oriented interface
 * @export
 * @class CampaignApi
 * @extends {BaseAPI}
 */
export class CampaignApi extends BaseAPI {
    /**
     * 
     * @param {Campaign} campaign 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CampaignApi
     */
    public campaignCreate(campaign: Campaign, options?: RawAxiosRequestConfig) {
        return CampaignApiFp(this.configuration).campaignCreate(campaign, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this campaign.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CampaignApi
     */
    public campaignDestroy(id: number, options?: RawAxiosRequestConfig) {
        return CampaignApiFp(this.configuration).campaignDestroy(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CampaignApi
     */
    public campaignList(options?: RawAxiosRequestConfig) {
        return CampaignApiFp(this.configuration).campaignList(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this campaign.
     * @param {PatchedCampaign} [patchedCampaign] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CampaignApi
     */
    public campaignPartialUpdate(id: number, patchedCampaign?: PatchedCampaign, options?: RawAxiosRequestConfig) {
        return CampaignApiFp(this.configuration).campaignPartialUpdate(id, patchedCampaign, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this campaign.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CampaignApi
     */
    public campaignRetrieve(id: number, options?: RawAxiosRequestConfig) {
        return CampaignApiFp(this.configuration).campaignRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} campaignId 
     * @param {CampaignRound} campaignRound 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CampaignApi
     */
    public campaignRoundCreate(campaignId: string, campaignRound: CampaignRound, options?: RawAxiosRequestConfig) {
        return CampaignApiFp(this.configuration).campaignRoundCreate(campaignId, campaignRound, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} campaignId 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CampaignApi
     */
    public campaignRoundDestroy(campaignId: string, id: string, options?: RawAxiosRequestConfig) {
        return CampaignApiFp(this.configuration).campaignRoundDestroy(campaignId, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} campaignId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CampaignApi
     */
    public campaignRoundList(campaignId: string, options?: RawAxiosRequestConfig) {
        return CampaignApiFp(this.configuration).campaignRoundList(campaignId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} campaignId 
     * @param {string} id 
     * @param {PatchedCampaignRound} [patchedCampaignRound] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CampaignApi
     */
    public campaignRoundPartialUpdate(campaignId: string, id: string, patchedCampaignRound?: PatchedCampaignRound, options?: RawAxiosRequestConfig) {
        return CampaignApiFp(this.configuration).campaignRoundPartialUpdate(campaignId, id, patchedCampaignRound, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} campaignId 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CampaignApi
     */
    public campaignRoundRetrieve(campaignId: string, id: string, options?: RawAxiosRequestConfig) {
        return CampaignApiFp(this.configuration).campaignRoundRetrieve(campaignId, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} campaignId 
     * @param {string} id 
     * @param {CampaignRound} campaignRound 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CampaignApi
     */
    public campaignRoundUpdate(campaignId: string, id: string, campaignRound: CampaignRound, options?: RawAxiosRequestConfig) {
        return CampaignApiFp(this.configuration).campaignRoundUpdate(campaignId, id, campaignRound, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this campaign.
     * @param {Campaign} campaign 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CampaignApi
     */
    public campaignUpdate(id: number, campaign: Campaign, options?: RawAxiosRequestConfig) {
        return CampaignApiFp(this.configuration).campaignUpdate(id, campaign, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * FileApi - axios parameter creator
 * @export
 */
export const FileApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {RelatedFile} relatedFile 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fileCreate: async (relatedFile: RelatedFile, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'relatedFile' is not null or undefined
            assertParamExists('fileCreate', 'relatedFile', relatedFile)
            const localVarPath = `/api/file/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(relatedFile, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this related file.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fileDestroy: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('fileDestroy', 'id', id)
            const localVarPath = `/api/file/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fileList: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/file/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this related file.
         * @param {PatchedRelatedFile} [patchedRelatedFile] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        filePartialUpdate: async (id: number, patchedRelatedFile?: PatchedRelatedFile, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('filePartialUpdate', 'id', id)
            const localVarPath = `/api/file/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedRelatedFile, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this related file.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fileRetrieve: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('fileRetrieve', 'id', id)
            const localVarPath = `/api/file/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * FileApi - functional programming interface
 * @export
 */
export const FileApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = FileApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {RelatedFile} relatedFile 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async fileCreate(relatedFile: RelatedFile, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RelatedFile>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.fileCreate(relatedFile, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FileApi.fileCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this related file.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async fileDestroy(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.fileDestroy(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FileApi.fileDestroy']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async fileList(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<RelatedFile>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.fileList(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FileApi.fileList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this related file.
         * @param {PatchedRelatedFile} [patchedRelatedFile] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async filePartialUpdate(id: number, patchedRelatedFile?: PatchedRelatedFile, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RelatedFile>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.filePartialUpdate(id, patchedRelatedFile, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FileApi.filePartialUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this related file.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async fileRetrieve(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RelatedFile>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.fileRetrieve(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FileApi.fileRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * FileApi - factory interface
 * @export
 */
export const FileApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = FileApiFp(configuration)
    return {
        /**
         * 
         * @param {RelatedFile} relatedFile 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fileCreate(relatedFile: RelatedFile, options?: RawAxiosRequestConfig): AxiosPromise<RelatedFile> {
            return localVarFp.fileCreate(relatedFile, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this related file.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fileDestroy(id: number, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.fileDestroy(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fileList(options?: RawAxiosRequestConfig): AxiosPromise<Array<RelatedFile>> {
            return localVarFp.fileList(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this related file.
         * @param {PatchedRelatedFile} [patchedRelatedFile] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        filePartialUpdate(id: number, patchedRelatedFile?: PatchedRelatedFile, options?: RawAxiosRequestConfig): AxiosPromise<RelatedFile> {
            return localVarFp.filePartialUpdate(id, patchedRelatedFile, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this related file.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fileRetrieve(id: number, options?: RawAxiosRequestConfig): AxiosPromise<RelatedFile> {
            return localVarFp.fileRetrieve(id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * FileApi - object-oriented interface
 * @export
 * @class FileApi
 * @extends {BaseAPI}
 */
export class FileApi extends BaseAPI {
    /**
     * 
     * @param {RelatedFile} relatedFile 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FileApi
     */
    public fileCreate(relatedFile: RelatedFile, options?: RawAxiosRequestConfig) {
        return FileApiFp(this.configuration).fileCreate(relatedFile, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this related file.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FileApi
     */
    public fileDestroy(id: number, options?: RawAxiosRequestConfig) {
        return FileApiFp(this.configuration).fileDestroy(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FileApi
     */
    public fileList(options?: RawAxiosRequestConfig) {
        return FileApiFp(this.configuration).fileList(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this related file.
     * @param {PatchedRelatedFile} [patchedRelatedFile] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FileApi
     */
    public filePartialUpdate(id: number, patchedRelatedFile?: PatchedRelatedFile, options?: RawAxiosRequestConfig) {
        return FileApiFp(this.configuration).filePartialUpdate(id, patchedRelatedFile, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this related file.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FileApi
     */
    public fileRetrieve(id: number, options?: RawAxiosRequestConfig) {
        return FileApiFp(this.configuration).fileRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * IdeaApi - axios parameter creator
 * @export
 */
export const IdeaApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} campaignId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ideaCampaignIdeaList: async (campaignId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'campaignId' is not null or undefined
            assertParamExists('ideaCampaignIdeaList', 'campaignId', campaignId)
            const localVarPath = `/api/idea/campaign/{campaign_id}/idea/`
                .replace(`{${"campaign_id"}}`, encodeURIComponent(String(campaignId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Idea} idea 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ideaCreate: async (idea: Idea, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'idea' is not null or undefined
            assertParamExists('ideaCreate', 'idea', idea)
            const localVarPath = `/api/idea/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(idea, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this idea.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ideaDestroy: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('ideaDestroy', 'id', id)
            const localVarPath = `/api/idea/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} ideaId 
         * @param {IdeaInformation} [ideaInformation] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ideaInformationCreate: async (ideaId: string, ideaInformation?: IdeaInformation, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ideaId' is not null or undefined
            assertParamExists('ideaInformationCreate', 'ideaId', ideaId)
            const localVarPath = `/api/idea/{idea_id}/information/`
                .replace(`{${"idea_id"}}`, encodeURIComponent(String(ideaId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(ideaInformation, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this information.
         * @param {string} ideaId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ideaInformationDestroy: async (id: number, ideaId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('ideaInformationDestroy', 'id', id)
            // verify required parameter 'ideaId' is not null or undefined
            assertParamExists('ideaInformationDestroy', 'ideaId', ideaId)
            const localVarPath = `/api/idea/{idea_id}/information/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"idea_id"}}`, encodeURIComponent(String(ideaId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} ideaId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ideaInformationList: async (ideaId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ideaId' is not null or undefined
            assertParamExists('ideaInformationList', 'ideaId', ideaId)
            const localVarPath = `/api/idea/{idea_id}/information/`
                .replace(`{${"idea_id"}}`, encodeURIComponent(String(ideaId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this information.
         * @param {string} ideaId 
         * @param {PatchedIdeaInformation} [patchedIdeaInformation] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ideaInformationPartialUpdate: async (id: number, ideaId: string, patchedIdeaInformation?: PatchedIdeaInformation, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('ideaInformationPartialUpdate', 'id', id)
            // verify required parameter 'ideaId' is not null or undefined
            assertParamExists('ideaInformationPartialUpdate', 'ideaId', ideaId)
            const localVarPath = `/api/idea/{idea_id}/information/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"idea_id"}}`, encodeURIComponent(String(ideaId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedIdeaInformation, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this information.
         * @param {string} ideaId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ideaInformationRetrieve: async (id: number, ideaId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('ideaInformationRetrieve', 'id', id)
            // verify required parameter 'ideaId' is not null or undefined
            assertParamExists('ideaInformationRetrieve', 'ideaId', ideaId)
            const localVarPath = `/api/idea/{idea_id}/information/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"idea_id"}}`, encodeURIComponent(String(ideaId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this information.
         * @param {string} ideaId 
         * @param {IdeaInformation} [ideaInformation] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ideaInformationUpdate: async (id: number, ideaId: string, ideaInformation?: IdeaInformation, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('ideaInformationUpdate', 'id', id)
            // verify required parameter 'ideaId' is not null or undefined
            assertParamExists('ideaInformationUpdate', 'ideaId', ideaId)
            const localVarPath = `/api/idea/{idea_id}/information/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"idea_id"}}`, encodeURIComponent(String(ideaId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(ideaInformation, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ideaList: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/idea/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this idea.
         * @param {PatchedIdea} [patchedIdea] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ideaPartialUpdate: async (id: number, patchedIdea?: PatchedIdea, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('ideaPartialUpdate', 'id', id)
            const localVarPath = `/api/idea/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedIdea, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this idea.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ideaRetrieve: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('ideaRetrieve', 'id', id)
            const localVarPath = `/api/idea/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} ideaId 
         * @param {string} roundId 
         * @param {IdeaInformation} [ideaInformation] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ideaRoundIdeaInformationCreate: async (ideaId: string, roundId: string, ideaInformation?: IdeaInformation, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ideaId' is not null or undefined
            assertParamExists('ideaRoundIdeaInformationCreate', 'ideaId', ideaId)
            // verify required parameter 'roundId' is not null or undefined
            assertParamExists('ideaRoundIdeaInformationCreate', 'roundId', roundId)
            const localVarPath = `/api/idea/round/{round_id}/idea/{idea_id}/information/`
                .replace(`{${"idea_id"}}`, encodeURIComponent(String(ideaId)))
                .replace(`{${"round_id"}}`, encodeURIComponent(String(roundId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(ideaInformation, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this information.
         * @param {string} ideaId 
         * @param {string} roundId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ideaRoundIdeaInformationDestroy: async (id: number, ideaId: string, roundId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('ideaRoundIdeaInformationDestroy', 'id', id)
            // verify required parameter 'ideaId' is not null or undefined
            assertParamExists('ideaRoundIdeaInformationDestroy', 'ideaId', ideaId)
            // verify required parameter 'roundId' is not null or undefined
            assertParamExists('ideaRoundIdeaInformationDestroy', 'roundId', roundId)
            const localVarPath = `/api/idea/round/{round_id}/idea/{idea_id}/information/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"idea_id"}}`, encodeURIComponent(String(ideaId)))
                .replace(`{${"round_id"}}`, encodeURIComponent(String(roundId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} ideaId 
         * @param {string} roundId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ideaRoundIdeaInformationList: async (ideaId: string, roundId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ideaId' is not null or undefined
            assertParamExists('ideaRoundIdeaInformationList', 'ideaId', ideaId)
            // verify required parameter 'roundId' is not null or undefined
            assertParamExists('ideaRoundIdeaInformationList', 'roundId', roundId)
            const localVarPath = `/api/idea/round/{round_id}/idea/{idea_id}/information/`
                .replace(`{${"idea_id"}}`, encodeURIComponent(String(ideaId)))
                .replace(`{${"round_id"}}`, encodeURIComponent(String(roundId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this information.
         * @param {string} ideaId 
         * @param {string} roundId 
         * @param {PatchedIdeaInformation} [patchedIdeaInformation] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ideaRoundIdeaInformationPartialUpdate: async (id: number, ideaId: string, roundId: string, patchedIdeaInformation?: PatchedIdeaInformation, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('ideaRoundIdeaInformationPartialUpdate', 'id', id)
            // verify required parameter 'ideaId' is not null or undefined
            assertParamExists('ideaRoundIdeaInformationPartialUpdate', 'ideaId', ideaId)
            // verify required parameter 'roundId' is not null or undefined
            assertParamExists('ideaRoundIdeaInformationPartialUpdate', 'roundId', roundId)
            const localVarPath = `/api/idea/round/{round_id}/idea/{idea_id}/information/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"idea_id"}}`, encodeURIComponent(String(ideaId)))
                .replace(`{${"round_id"}}`, encodeURIComponent(String(roundId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedIdeaInformation, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this information.
         * @param {string} ideaId 
         * @param {string} roundId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ideaRoundIdeaInformationRetrieve: async (id: number, ideaId: string, roundId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('ideaRoundIdeaInformationRetrieve', 'id', id)
            // verify required parameter 'ideaId' is not null or undefined
            assertParamExists('ideaRoundIdeaInformationRetrieve', 'ideaId', ideaId)
            // verify required parameter 'roundId' is not null or undefined
            assertParamExists('ideaRoundIdeaInformationRetrieve', 'roundId', roundId)
            const localVarPath = `/api/idea/round/{round_id}/idea/{idea_id}/information/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"idea_id"}}`, encodeURIComponent(String(ideaId)))
                .replace(`{${"round_id"}}`, encodeURIComponent(String(roundId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this information.
         * @param {string} ideaId 
         * @param {string} roundId 
         * @param {IdeaInformation} [ideaInformation] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ideaRoundIdeaInformationUpdate: async (id: number, ideaId: string, roundId: string, ideaInformation?: IdeaInformation, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('ideaRoundIdeaInformationUpdate', 'id', id)
            // verify required parameter 'ideaId' is not null or undefined
            assertParamExists('ideaRoundIdeaInformationUpdate', 'ideaId', ideaId)
            // verify required parameter 'roundId' is not null or undefined
            assertParamExists('ideaRoundIdeaInformationUpdate', 'roundId', roundId)
            const localVarPath = `/api/idea/round/{round_id}/idea/{idea_id}/information/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"idea_id"}}`, encodeURIComponent(String(ideaId)))
                .replace(`{${"round_id"}}`, encodeURIComponent(String(roundId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(ideaInformation, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} ideaId 
         * @param {string} roundId 
         * @param {Vote} vote 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ideaRoundIdeaVoteMeCreate: async (ideaId: string, roundId: string, vote: Vote, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ideaId' is not null or undefined
            assertParamExists('ideaRoundIdeaVoteMeCreate', 'ideaId', ideaId)
            // verify required parameter 'roundId' is not null or undefined
            assertParamExists('ideaRoundIdeaVoteMeCreate', 'roundId', roundId)
            // verify required parameter 'vote' is not null or undefined
            assertParamExists('ideaRoundIdeaVoteMeCreate', 'vote', vote)
            const localVarPath = `/api/idea/round/{round_id}/idea/{idea_id}/vote/me/`
                .replace(`{${"idea_id"}}`, encodeURIComponent(String(ideaId)))
                .replace(`{${"round_id"}}`, encodeURIComponent(String(roundId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(vote, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} ideaId 
         * @param {string} roundId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ideaRoundIdeaVoteMeList: async (ideaId: string, roundId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ideaId' is not null or undefined
            assertParamExists('ideaRoundIdeaVoteMeList', 'ideaId', ideaId)
            // verify required parameter 'roundId' is not null or undefined
            assertParamExists('ideaRoundIdeaVoteMeList', 'roundId', roundId)
            const localVarPath = `/api/idea/round/{round_id}/idea/{idea_id}/vote/me/`
                .replace(`{${"idea_id"}}`, encodeURIComponent(String(ideaId)))
                .replace(`{${"round_id"}}`, encodeURIComponent(String(roundId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} roundId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ideaRoundVoteMeList: async (roundId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'roundId' is not null or undefined
            assertParamExists('ideaRoundVoteMeList', 'roundId', roundId)
            const localVarPath = `/api/idea/round/{round_id}/vote/me/`
                .replace(`{${"round_id"}}`, encodeURIComponent(String(roundId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this idea.
         * @param {Idea} idea 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ideaUpdate: async (id: number, idea: Idea, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('ideaUpdate', 'id', id)
            // verify required parameter 'idea' is not null or undefined
            assertParamExists('ideaUpdate', 'idea', idea)
            const localVarPath = `/api/idea/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(idea, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this vote.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ideaVoteDestroy: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('ideaVoteDestroy', 'id', id)
            const localVarPath = `/api/idea/vote/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * IdeaApi - functional programming interface
 * @export
 */
export const IdeaApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = IdeaApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} campaignId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ideaCampaignIdeaList(campaignId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<IdeaDetail>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ideaCampaignIdeaList(campaignId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['IdeaApi.ideaCampaignIdeaList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {Idea} idea 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ideaCreate(idea: Idea, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Idea>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ideaCreate(idea, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['IdeaApi.ideaCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this idea.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ideaDestroy(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ideaDestroy(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['IdeaApi.ideaDestroy']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} ideaId 
         * @param {IdeaInformation} [ideaInformation] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ideaInformationCreate(ideaId: string, ideaInformation?: IdeaInformation, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IdeaInformation>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ideaInformationCreate(ideaId, ideaInformation, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['IdeaApi.ideaInformationCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this information.
         * @param {string} ideaId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ideaInformationDestroy(id: number, ideaId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ideaInformationDestroy(id, ideaId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['IdeaApi.ideaInformationDestroy']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} ideaId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ideaInformationList(ideaId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<IdeaInformation>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ideaInformationList(ideaId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['IdeaApi.ideaInformationList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this information.
         * @param {string} ideaId 
         * @param {PatchedIdeaInformation} [patchedIdeaInformation] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ideaInformationPartialUpdate(id: number, ideaId: string, patchedIdeaInformation?: PatchedIdeaInformation, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IdeaInformation>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ideaInformationPartialUpdate(id, ideaId, patchedIdeaInformation, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['IdeaApi.ideaInformationPartialUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this information.
         * @param {string} ideaId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ideaInformationRetrieve(id: number, ideaId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IdeaInformation>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ideaInformationRetrieve(id, ideaId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['IdeaApi.ideaInformationRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this information.
         * @param {string} ideaId 
         * @param {IdeaInformation} [ideaInformation] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ideaInformationUpdate(id: number, ideaId: string, ideaInformation?: IdeaInformation, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IdeaInformation>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ideaInformationUpdate(id, ideaId, ideaInformation, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['IdeaApi.ideaInformationUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ideaList(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Idea>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ideaList(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['IdeaApi.ideaList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this idea.
         * @param {PatchedIdea} [patchedIdea] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ideaPartialUpdate(id: number, patchedIdea?: PatchedIdea, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Idea>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ideaPartialUpdate(id, patchedIdea, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['IdeaApi.ideaPartialUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this idea.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ideaRetrieve(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IdeaDetail>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ideaRetrieve(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['IdeaApi.ideaRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} ideaId 
         * @param {string} roundId 
         * @param {IdeaInformation} [ideaInformation] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ideaRoundIdeaInformationCreate(ideaId: string, roundId: string, ideaInformation?: IdeaInformation, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IdeaInformation>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ideaRoundIdeaInformationCreate(ideaId, roundId, ideaInformation, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['IdeaApi.ideaRoundIdeaInformationCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this information.
         * @param {string} ideaId 
         * @param {string} roundId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ideaRoundIdeaInformationDestroy(id: number, ideaId: string, roundId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ideaRoundIdeaInformationDestroy(id, ideaId, roundId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['IdeaApi.ideaRoundIdeaInformationDestroy']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} ideaId 
         * @param {string} roundId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ideaRoundIdeaInformationList(ideaId: string, roundId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<IdeaInformation>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ideaRoundIdeaInformationList(ideaId, roundId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['IdeaApi.ideaRoundIdeaInformationList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this information.
         * @param {string} ideaId 
         * @param {string} roundId 
         * @param {PatchedIdeaInformation} [patchedIdeaInformation] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ideaRoundIdeaInformationPartialUpdate(id: number, ideaId: string, roundId: string, patchedIdeaInformation?: PatchedIdeaInformation, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IdeaInformation>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ideaRoundIdeaInformationPartialUpdate(id, ideaId, roundId, patchedIdeaInformation, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['IdeaApi.ideaRoundIdeaInformationPartialUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this information.
         * @param {string} ideaId 
         * @param {string} roundId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ideaRoundIdeaInformationRetrieve(id: number, ideaId: string, roundId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IdeaInformation>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ideaRoundIdeaInformationRetrieve(id, ideaId, roundId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['IdeaApi.ideaRoundIdeaInformationRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this information.
         * @param {string} ideaId 
         * @param {string} roundId 
         * @param {IdeaInformation} [ideaInformation] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ideaRoundIdeaInformationUpdate(id: number, ideaId: string, roundId: string, ideaInformation?: IdeaInformation, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IdeaInformation>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ideaRoundIdeaInformationUpdate(id, ideaId, roundId, ideaInformation, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['IdeaApi.ideaRoundIdeaInformationUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} ideaId 
         * @param {string} roundId 
         * @param {Vote} vote 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ideaRoundIdeaVoteMeCreate(ideaId: string, roundId: string, vote: Vote, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Vote>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ideaRoundIdeaVoteMeCreate(ideaId, roundId, vote, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['IdeaApi.ideaRoundIdeaVoteMeCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} ideaId 
         * @param {string} roundId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ideaRoundIdeaVoteMeList(ideaId: string, roundId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Vote>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ideaRoundIdeaVoteMeList(ideaId, roundId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['IdeaApi.ideaRoundIdeaVoteMeList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} roundId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ideaRoundVoteMeList(roundId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Vote>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ideaRoundVoteMeList(roundId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['IdeaApi.ideaRoundVoteMeList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this idea.
         * @param {Idea} idea 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ideaUpdate(id: number, idea: Idea, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Idea>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ideaUpdate(id, idea, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['IdeaApi.ideaUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this vote.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ideaVoteDestroy(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ideaVoteDestroy(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['IdeaApi.ideaVoteDestroy']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * IdeaApi - factory interface
 * @export
 */
export const IdeaApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = IdeaApiFp(configuration)
    return {
        /**
         * 
         * @param {string} campaignId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ideaCampaignIdeaList(campaignId: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<IdeaDetail>> {
            return localVarFp.ideaCampaignIdeaList(campaignId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {Idea} idea 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ideaCreate(idea: Idea, options?: RawAxiosRequestConfig): AxiosPromise<Idea> {
            return localVarFp.ideaCreate(idea, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this idea.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ideaDestroy(id: number, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.ideaDestroy(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} ideaId 
         * @param {IdeaInformation} [ideaInformation] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ideaInformationCreate(ideaId: string, ideaInformation?: IdeaInformation, options?: RawAxiosRequestConfig): AxiosPromise<IdeaInformation> {
            return localVarFp.ideaInformationCreate(ideaId, ideaInformation, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this information.
         * @param {string} ideaId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ideaInformationDestroy(id: number, ideaId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.ideaInformationDestroy(id, ideaId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} ideaId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ideaInformationList(ideaId: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<IdeaInformation>> {
            return localVarFp.ideaInformationList(ideaId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this information.
         * @param {string} ideaId 
         * @param {PatchedIdeaInformation} [patchedIdeaInformation] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ideaInformationPartialUpdate(id: number, ideaId: string, patchedIdeaInformation?: PatchedIdeaInformation, options?: RawAxiosRequestConfig): AxiosPromise<IdeaInformation> {
            return localVarFp.ideaInformationPartialUpdate(id, ideaId, patchedIdeaInformation, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this information.
         * @param {string} ideaId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ideaInformationRetrieve(id: number, ideaId: string, options?: RawAxiosRequestConfig): AxiosPromise<IdeaInformation> {
            return localVarFp.ideaInformationRetrieve(id, ideaId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this information.
         * @param {string} ideaId 
         * @param {IdeaInformation} [ideaInformation] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ideaInformationUpdate(id: number, ideaId: string, ideaInformation?: IdeaInformation, options?: RawAxiosRequestConfig): AxiosPromise<IdeaInformation> {
            return localVarFp.ideaInformationUpdate(id, ideaId, ideaInformation, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ideaList(options?: RawAxiosRequestConfig): AxiosPromise<Array<Idea>> {
            return localVarFp.ideaList(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this idea.
         * @param {PatchedIdea} [patchedIdea] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ideaPartialUpdate(id: number, patchedIdea?: PatchedIdea, options?: RawAxiosRequestConfig): AxiosPromise<Idea> {
            return localVarFp.ideaPartialUpdate(id, patchedIdea, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this idea.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ideaRetrieve(id: number, options?: RawAxiosRequestConfig): AxiosPromise<IdeaDetail> {
            return localVarFp.ideaRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} ideaId 
         * @param {string} roundId 
         * @param {IdeaInformation} [ideaInformation] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ideaRoundIdeaInformationCreate(ideaId: string, roundId: string, ideaInformation?: IdeaInformation, options?: RawAxiosRequestConfig): AxiosPromise<IdeaInformation> {
            return localVarFp.ideaRoundIdeaInformationCreate(ideaId, roundId, ideaInformation, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this information.
         * @param {string} ideaId 
         * @param {string} roundId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ideaRoundIdeaInformationDestroy(id: number, ideaId: string, roundId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.ideaRoundIdeaInformationDestroy(id, ideaId, roundId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} ideaId 
         * @param {string} roundId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ideaRoundIdeaInformationList(ideaId: string, roundId: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<IdeaInformation>> {
            return localVarFp.ideaRoundIdeaInformationList(ideaId, roundId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this information.
         * @param {string} ideaId 
         * @param {string} roundId 
         * @param {PatchedIdeaInformation} [patchedIdeaInformation] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ideaRoundIdeaInformationPartialUpdate(id: number, ideaId: string, roundId: string, patchedIdeaInformation?: PatchedIdeaInformation, options?: RawAxiosRequestConfig): AxiosPromise<IdeaInformation> {
            return localVarFp.ideaRoundIdeaInformationPartialUpdate(id, ideaId, roundId, patchedIdeaInformation, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this information.
         * @param {string} ideaId 
         * @param {string} roundId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ideaRoundIdeaInformationRetrieve(id: number, ideaId: string, roundId: string, options?: RawAxiosRequestConfig): AxiosPromise<IdeaInformation> {
            return localVarFp.ideaRoundIdeaInformationRetrieve(id, ideaId, roundId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this information.
         * @param {string} ideaId 
         * @param {string} roundId 
         * @param {IdeaInformation} [ideaInformation] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ideaRoundIdeaInformationUpdate(id: number, ideaId: string, roundId: string, ideaInformation?: IdeaInformation, options?: RawAxiosRequestConfig): AxiosPromise<IdeaInformation> {
            return localVarFp.ideaRoundIdeaInformationUpdate(id, ideaId, roundId, ideaInformation, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} ideaId 
         * @param {string} roundId 
         * @param {Vote} vote 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ideaRoundIdeaVoteMeCreate(ideaId: string, roundId: string, vote: Vote, options?: RawAxiosRequestConfig): AxiosPromise<Vote> {
            return localVarFp.ideaRoundIdeaVoteMeCreate(ideaId, roundId, vote, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} ideaId 
         * @param {string} roundId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ideaRoundIdeaVoteMeList(ideaId: string, roundId: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<Vote>> {
            return localVarFp.ideaRoundIdeaVoteMeList(ideaId, roundId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} roundId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ideaRoundVoteMeList(roundId: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<Vote>> {
            return localVarFp.ideaRoundVoteMeList(roundId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this idea.
         * @param {Idea} idea 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ideaUpdate(id: number, idea: Idea, options?: RawAxiosRequestConfig): AxiosPromise<Idea> {
            return localVarFp.ideaUpdate(id, idea, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this vote.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ideaVoteDestroy(id: number, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.ideaVoteDestroy(id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * IdeaApi - object-oriented interface
 * @export
 * @class IdeaApi
 * @extends {BaseAPI}
 */
export class IdeaApi extends BaseAPI {
    /**
     * 
     * @param {string} campaignId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IdeaApi
     */
    public ideaCampaignIdeaList(campaignId: string, options?: RawAxiosRequestConfig) {
        return IdeaApiFp(this.configuration).ideaCampaignIdeaList(campaignId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {Idea} idea 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IdeaApi
     */
    public ideaCreate(idea: Idea, options?: RawAxiosRequestConfig) {
        return IdeaApiFp(this.configuration).ideaCreate(idea, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this idea.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IdeaApi
     */
    public ideaDestroy(id: number, options?: RawAxiosRequestConfig) {
        return IdeaApiFp(this.configuration).ideaDestroy(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} ideaId 
     * @param {IdeaInformation} [ideaInformation] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IdeaApi
     */
    public ideaInformationCreate(ideaId: string, ideaInformation?: IdeaInformation, options?: RawAxiosRequestConfig) {
        return IdeaApiFp(this.configuration).ideaInformationCreate(ideaId, ideaInformation, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this information.
     * @param {string} ideaId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IdeaApi
     */
    public ideaInformationDestroy(id: number, ideaId: string, options?: RawAxiosRequestConfig) {
        return IdeaApiFp(this.configuration).ideaInformationDestroy(id, ideaId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} ideaId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IdeaApi
     */
    public ideaInformationList(ideaId: string, options?: RawAxiosRequestConfig) {
        return IdeaApiFp(this.configuration).ideaInformationList(ideaId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this information.
     * @param {string} ideaId 
     * @param {PatchedIdeaInformation} [patchedIdeaInformation] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IdeaApi
     */
    public ideaInformationPartialUpdate(id: number, ideaId: string, patchedIdeaInformation?: PatchedIdeaInformation, options?: RawAxiosRequestConfig) {
        return IdeaApiFp(this.configuration).ideaInformationPartialUpdate(id, ideaId, patchedIdeaInformation, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this information.
     * @param {string} ideaId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IdeaApi
     */
    public ideaInformationRetrieve(id: number, ideaId: string, options?: RawAxiosRequestConfig) {
        return IdeaApiFp(this.configuration).ideaInformationRetrieve(id, ideaId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this information.
     * @param {string} ideaId 
     * @param {IdeaInformation} [ideaInformation] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IdeaApi
     */
    public ideaInformationUpdate(id: number, ideaId: string, ideaInformation?: IdeaInformation, options?: RawAxiosRequestConfig) {
        return IdeaApiFp(this.configuration).ideaInformationUpdate(id, ideaId, ideaInformation, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IdeaApi
     */
    public ideaList(options?: RawAxiosRequestConfig) {
        return IdeaApiFp(this.configuration).ideaList(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this idea.
     * @param {PatchedIdea} [patchedIdea] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IdeaApi
     */
    public ideaPartialUpdate(id: number, patchedIdea?: PatchedIdea, options?: RawAxiosRequestConfig) {
        return IdeaApiFp(this.configuration).ideaPartialUpdate(id, patchedIdea, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this idea.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IdeaApi
     */
    public ideaRetrieve(id: number, options?: RawAxiosRequestConfig) {
        return IdeaApiFp(this.configuration).ideaRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} ideaId 
     * @param {string} roundId 
     * @param {IdeaInformation} [ideaInformation] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IdeaApi
     */
    public ideaRoundIdeaInformationCreate(ideaId: string, roundId: string, ideaInformation?: IdeaInformation, options?: RawAxiosRequestConfig) {
        return IdeaApiFp(this.configuration).ideaRoundIdeaInformationCreate(ideaId, roundId, ideaInformation, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this information.
     * @param {string} ideaId 
     * @param {string} roundId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IdeaApi
     */
    public ideaRoundIdeaInformationDestroy(id: number, ideaId: string, roundId: string, options?: RawAxiosRequestConfig) {
        return IdeaApiFp(this.configuration).ideaRoundIdeaInformationDestroy(id, ideaId, roundId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} ideaId 
     * @param {string} roundId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IdeaApi
     */
    public ideaRoundIdeaInformationList(ideaId: string, roundId: string, options?: RawAxiosRequestConfig) {
        return IdeaApiFp(this.configuration).ideaRoundIdeaInformationList(ideaId, roundId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this information.
     * @param {string} ideaId 
     * @param {string} roundId 
     * @param {PatchedIdeaInformation} [patchedIdeaInformation] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IdeaApi
     */
    public ideaRoundIdeaInformationPartialUpdate(id: number, ideaId: string, roundId: string, patchedIdeaInformation?: PatchedIdeaInformation, options?: RawAxiosRequestConfig) {
        return IdeaApiFp(this.configuration).ideaRoundIdeaInformationPartialUpdate(id, ideaId, roundId, patchedIdeaInformation, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this information.
     * @param {string} ideaId 
     * @param {string} roundId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IdeaApi
     */
    public ideaRoundIdeaInformationRetrieve(id: number, ideaId: string, roundId: string, options?: RawAxiosRequestConfig) {
        return IdeaApiFp(this.configuration).ideaRoundIdeaInformationRetrieve(id, ideaId, roundId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this information.
     * @param {string} ideaId 
     * @param {string} roundId 
     * @param {IdeaInformation} [ideaInformation] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IdeaApi
     */
    public ideaRoundIdeaInformationUpdate(id: number, ideaId: string, roundId: string, ideaInformation?: IdeaInformation, options?: RawAxiosRequestConfig) {
        return IdeaApiFp(this.configuration).ideaRoundIdeaInformationUpdate(id, ideaId, roundId, ideaInformation, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} ideaId 
     * @param {string} roundId 
     * @param {Vote} vote 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IdeaApi
     */
    public ideaRoundIdeaVoteMeCreate(ideaId: string, roundId: string, vote: Vote, options?: RawAxiosRequestConfig) {
        return IdeaApiFp(this.configuration).ideaRoundIdeaVoteMeCreate(ideaId, roundId, vote, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} ideaId 
     * @param {string} roundId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IdeaApi
     */
    public ideaRoundIdeaVoteMeList(ideaId: string, roundId: string, options?: RawAxiosRequestConfig) {
        return IdeaApiFp(this.configuration).ideaRoundIdeaVoteMeList(ideaId, roundId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} roundId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IdeaApi
     */
    public ideaRoundVoteMeList(roundId: string, options?: RawAxiosRequestConfig) {
        return IdeaApiFp(this.configuration).ideaRoundVoteMeList(roundId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this idea.
     * @param {Idea} idea 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IdeaApi
     */
    public ideaUpdate(id: number, idea: Idea, options?: RawAxiosRequestConfig) {
        return IdeaApiFp(this.configuration).ideaUpdate(id, idea, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this vote.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IdeaApi
     */
    public ideaVoteDestroy(id: number, options?: RawAxiosRequestConfig) {
        return IdeaApiFp(this.configuration).ideaVoteDestroy(id, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * UserApi - axios parameter creator
 * @export
 */
export const UserApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * View to work with profile for the currently logged in user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userMeProfileRetrieve: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/user/me/profile/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * View to return data about the currently logged in user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userMeRetrieve: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/user/me/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * View to return data about a specific user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userRetrieve: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/user/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookieAuth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UserApi - functional programming interface
 * @export
 */
export const UserApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UserApiAxiosParamCreator(configuration)
    return {
        /**
         * View to work with profile for the currently logged in user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userMeProfileRetrieve(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserProfile>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userMeProfileRetrieve(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.userMeProfileRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * View to return data about the currently logged in user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userMeRetrieve(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserWithPermissions>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userMeRetrieve(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.userMeRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * View to return data about a specific user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userRetrieve(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserWithPermissions>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userRetrieve(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.userRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * UserApi - factory interface
 * @export
 */
export const UserApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UserApiFp(configuration)
    return {
        /**
         * View to work with profile for the currently logged in user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userMeProfileRetrieve(options?: RawAxiosRequestConfig): AxiosPromise<UserProfile> {
            return localVarFp.userMeProfileRetrieve(options).then((request) => request(axios, basePath));
        },
        /**
         * View to return data about the currently logged in user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userMeRetrieve(options?: RawAxiosRequestConfig): AxiosPromise<UserWithPermissions> {
            return localVarFp.userMeRetrieve(options).then((request) => request(axios, basePath));
        },
        /**
         * View to return data about a specific user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userRetrieve(options?: RawAxiosRequestConfig): AxiosPromise<UserWithPermissions> {
            return localVarFp.userRetrieve(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UserApi - object-oriented interface
 * @export
 * @class UserApi
 * @extends {BaseAPI}
 */
export class UserApi extends BaseAPI {
    /**
     * View to work with profile for the currently logged in user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public userMeProfileRetrieve(options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).userMeProfileRetrieve(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * View to return data about the currently logged in user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public userMeRetrieve(options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).userMeRetrieve(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * View to return data about a specific user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public userRetrieve(options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).userRetrieve(options).then((request) => request(this.axios, this.basePath));
    }
}



